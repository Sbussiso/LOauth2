name: Server E2E test

on:
  push:
  pull_request:

permissions:
  contents: read

jobs:
  run-server:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ['3.10', '3.11', '3.12']
    timeout-minutes: 15
    env:
      BASE: http://127.0.0.1:8000
      ADMIN_TOKEN: ci-admin-token
      ENABLE_DEV_ENDPOINTS: "true"
      CLIENT_ID: demo-web
      REDIRECT_URI: http://localhost:3000/callback
      SCOPE: openid profile email offline_access
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Set up uv
        uses: astral-sh/setup-uv@v3

      - name: Cache uv wheels
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/uv
          key: ${{ runner.os }}-uv-${{ matrix.python-version }}-${{ hashFiles('**/server.py') }}
          restore-keys: |
            ${{ runner.os }}-uv-${{ matrix.python-version }}-

      - name: Cache apt packages (jq)
        uses: awalsh128/cache-apt-pkgs-action@v1
        with:
          packages: jq
          version: 1

      - name: Start server (uv)
        run: |
          set -euo pipefail
          nohup uv run --with flask --with authlib --with sqlalchemy --with gunicorn \
            gunicorn -w 1 -b 127.0.0.1:8000 server:app > server.log 2>&1 &
          echo $! > server.pid

      - name: Wait for health
        run: |
          set -euo pipefail
          for i in {1..60}; do
            if curl -fsS --retry 3 --retry-all-errors --connect-timeout 2 --max-time 5 "$BASE/health" >/dev/null; then
              echo "Server is healthy"; exit 0; fi
            sleep 1; done
          echo "Server failed to become healthy"; exit 1

      - name: Initialize server (setup admin token)
        run: |
          set -euo pipefail
          # POST /setup to set admin token (idempotent on clean CI runner)
          curl -fsS --retry 3 --retry-all-errors -X POST "$BASE/setup" \
            -H 'Content-Type: application/x-www-form-urlencoded' \
            --data-urlencode "admin_token=$ADMIN_TOKEN" \
            -o /dev/null

      - name: Seed demo users and client (dev helpers)
        run: |
          set -euo pipefail
          curl -fsS --retry 3 --retry-all-errors "$BASE/dev/seed" -H "X-Admin-Token: $ADMIN_TOKEN" -o /dev/null

      - name: Generate PKCE (dev helper)
        run: |
          set -euo pipefail
          curl -fsS --retry 3 --retry-all-errors "$BASE/dev/pkce" -H "X-Admin-Token: $ADMIN_TOKEN" | tee pkce.json
          echo "PKCE:"; cat pkce.json
          echo
          echo "::group::Extract PKCE"
          CODE_VERIFIER=$(jq -r '.code_verifier' pkce.json)
          CODE_CHALLENGE=$(jq -r '.code_challenge' pkce.json)
          if [ -z "$CODE_VERIFIER" ] || [ -z "$CODE_CHALLENGE" ]; then echo "Failed to parse PKCE"; exit 1; fi
          echo "CODE_VERIFIER=$CODE_VERIFIER" >> $GITHUB_ENV
          echo "CODE_CHALLENGE=$CODE_CHALLENGE" >> $GITHUB_ENV
          echo "::endgroup::"

      - name: Build authorize URL
        run: |
          set -euo pipefail
          ENC_REDIRECT=$(uv run python -c "import urllib.parse, os; print(urllib.parse.quote_plus(os.environ['REDIRECT_URI']))")
          ENC_SCOPE=$(uv run python -c "import urllib.parse, os; print(urllib.parse.quote_plus(os.environ['SCOPE']))")
          STATE=$(uv run python -c "import secrets; print(secrets.token_urlsafe(16))")
          AUTH_URL="$BASE/authorize?client_id=$CLIENT_ID&response_type=code&redirect_uri=$ENC_REDIRECT&scope=$ENC_SCOPE&code_challenge_method=S256&code_challenge=$CODE_CHALLENGE&state=$STATE"
          echo "AUTH_URL=$AUTH_URL" >> $GITHUB_ENV
          echo "STATE=$STATE" >> $GITHUB_ENV
          echo "ENC_SCOPE=$ENC_SCOPE" >> $GITHUB_ENV
          echo "Authorize URL: $AUTH_URL"

      - name: Login as alice and authorize (obtain code)
        run: |
          set -euo pipefail
          # Prepare cookie jar
          touch cookies.txt
          # Visit login
          curl -fsS --retry 3 --retry-all-errors -c cookies.txt -b cookies.txt "$BASE/login" -o /dev/null
          # Submit login form with next=AUTH_URL
          NEXT_ENC=$(uv run python -c "import urllib.parse, os; print(urllib.parse.quote_plus(os.environ['AUTH_URL']))")
          curl -fsS --retry 3 --retry-all-errors -i -c cookies.txt -b cookies.txt \
            -X POST "$BASE/login?next=$NEXT_ENC" \
            -H 'Content-Type: application/x-www-form-urlencoded' \
            --data-urlencode 'username=alice' \
            --data-urlencode 'password=alice' \
            -D login.out -o /dev/null
          echo '--- login.out (status + location) ---'
          head -n 20 login.out || true
          # Now POST to /authorize with consent to get the 302 to redirect_uri with ?code=...
          curl -fsS --retry 3 --retry-all-errors -i -c cookies.txt -b cookies.txt \
            -X POST "$AUTH_URL" \
            -H 'Content-Type: application/x-www-form-urlencoded' \
            --data-urlencode 'confirm=yes' \
            -D auth.out -o /dev/null || true
          echo '--- auth.out (headers) ---'
          cat auth.out
          CODE=$(awk 'BEGIN{IGNORECASE=1} /^Location: /{print $2}' auth.out | tr -d '\r' | sed -E 's/.*[?&]code=([^&]+).*/\1/')
          if [ -z "$CODE" ]; then echo "Failed to extract authorization code"; exit 1; fi
          echo "CODE=$CODE" >> $GITHUB_ENV

      - name: Exchange code for tokens
        run: |
          set -euo pipefail
          curl -fsS --retry 3 --retry-all-errors -X POST "$BASE/token" \
            -H 'Content-Type: application/x-www-form-urlencoded' \
            --data-urlencode 'grant_type=authorization_code' \
            --data-urlencode "client_id=$CLIENT_ID" \
            --data-urlencode "code_verifier=$CODE_VERIFIER" \
            --data-urlencode "code=$CODE" \
            --data-urlencode "redirect_uri=$REDIRECT_URI" | tee token.json
          ACCESS_TOKEN=$(jq -r '.access_token' token.json)
          REFRESH_TOKEN=$(jq -r '.refresh_token' token.json)
          if [ -z "$ACCESS_TOKEN" ] || [ "$ACCESS_TOKEN" = "null" ]; then echo "Access token missing"; cat token.json; exit 1; fi
          if [ -z "$REFRESH_TOKEN" ] || [ "$REFRESH_TOKEN" = "null" ]; then echo "Refresh token missing"; cat token.json; exit 1; fi
          echo "ACCESS_TOKEN=$ACCESS_TOKEN" >> $GITHUB_ENV
          echo "REFRESH_TOKEN=$REFRESH_TOKEN" >> $GITHUB_ENV

      - name: Call /userinfo
        run: |
          set -euo pipefail
          curl -fsS --retry 3 --retry-all-errors "$BASE/userinfo" -H "Authorization: Bearer $ACCESS_TOKEN" | tee userinfo.json
          jq -e '.preferred_username == "alice"' userinfo.json >/dev/null || { echo "userinfo did not return expected user"; cat userinfo.json; exit 1; }

      - name: Refresh token (with introspect/revoke checks)
        run: |
          set -euo pipefail
          # Introspect should be active before refresh
          curl -fsS --retry 3 --retry-all-errors -X POST "$BASE/introspect" \
            -d "client_id=$CLIENT_ID" -d "token=$ACCESS_TOKEN" | tee introspect_before.json
          jq -e '.active == true' introspect_before.json >/dev/null || { echo "Token not active before refresh"; cat introspect_before.json; exit 1; }

          # Refresh
          curl -fsS --retry 3 --retry-all-errors -X POST "$BASE/token" \
            -H 'Content-Type: application/x-www-form-urlencoded' \
            --data-urlencode 'grant_type=refresh_token' \
            --data-urlencode "client_id=$CLIENT_ID" \
            --data-urlencode "refresh_token=$REFRESH_TOKEN" | tee token2.json
          ACCESS_TOKEN2=$(jq -r '.access_token' token2.json)
          if [ -z "$ACCESS_TOKEN2" ] || [ "$ACCESS_TOKEN2" = "null" ]; then echo "Refresh exchange failed"; cat token2.json; exit 1; fi

          # Old token should now be inactive (rotation revokes old credential)
          curl -fsS --retry 3 --retry-all-errors -X POST "$BASE/introspect" \
            -d "client_id=$CLIENT_ID" -d "token=$ACCESS_TOKEN" | tee introspect_old_after_refresh.json
          jq -e '.active == false' introspect_old_after_refresh.json >/dev/null || { echo "Old token still active after refresh"; cat introspect_old_after_refresh.json; exit 1; }

          # New access token should be active
          curl -fsS --retry 3 --retry-all-errors -X POST "$BASE/introspect" \
            -d "client_id=$CLIENT_ID" -d "token=$ACCESS_TOKEN2" | tee introspect_new.json
          jq -e '.active == true' introspect_new.json >/dev/null || { echo "New token not active after refresh"; cat introspect_new.json; exit 1; }

          # Revoke new access token and verify inactive
          curl -fsS --retry 3 --retry-all-errors -X POST "$BASE/revoke" \
            -d "client_id=$CLIENT_ID" -d "token=$ACCESS_TOKEN2" -o /dev/null
          curl -fsS --retry 3 --retry-all-errors -X POST "$BASE/introspect" \
            -d "client_id=$CLIENT_ID" -d "token=$ACCESS_TOKEN2" | tee introspect_new_after_revoke.json
          jq -e '.active == false' introspect_new_after_revoke.json >/dev/null || { echo "Token still active after revoke"; cat introspect_new_after_revoke.json; exit 1; }

      - name: Introspect then revoke access token
        run: |
          set -euo pipefail
          echo "Introspection and revocation validated in previous step."

      - name: Logout redirect check
        run: |
          set -euo pipefail
          STATE=$(uv run python -c "import secrets; print(secrets.token_urlsafe(8))")
          curl -fsS -i "$BASE/logout?client_id=$CLIENT_ID&post_logout_redirect_uri=http://localhost:3000/callback&state=$STATE" -D logout.out -o /dev/null
          LOC=$(awk 'BEGIN{IGNORECASE=1} /^Location: /{print $2}' logout.out | tr -d '\r')
          echo "Logout Location: $LOC"
          echo "$LOC" | grep -q "/callback" || { echo "Logout redirect not allowed"; exit 1; }
          echo "$LOC" | grep -q "state=" || { echo "State param missing on logout redirect"; exit 1; }

      - name: Confidential client flow (client_secret_post)
        run: |
          set -euo pipefail
          SUFFIX=$(uv run python -c "import secrets; print(secrets.token_hex(3))")
          CPOST_ID="ci-conf-post-$SUFFIX"
          CPOST_SECRET=$(uv run python -c "import secrets; print(secrets.token_urlsafe(24))")
          RURI2="http://localhost:5000/oauth2/callback"
          # Create client
          curl -fsS --retry 3 --retry-all-errors -X POST "$BASE/admin/clients" \
            -H "X-Admin-Token: $ADMIN_TOKEN" -H 'Content-Type: application/json' \
            -d "{\"client_id\":\"$CPOST_ID\",\"client_secret\":\"$CPOST_SECRET\",\"client_name\":\"CI Confidential POST\",\"redirect_uris\":\"http://127.0.0.1:5000/oauth2/callback $RURI2\",\"scope\":\"openid profile email offline_access\",\"grant_types\":\"authorization_code refresh_token\",\"response_types\":\"code\",\"token_endpoint_auth_method\":\"client_secret_post\"}" -o /dev/null
          ENC_REDIRECT2=$(uv run python -c "import sys, urllib.parse as u; print(u.quote_plus(sys.argv[1]))" "$RURI2")
          AUTH_URL2="$BASE/authorize?client_id=$CPOST_ID&response_type=code&redirect_uri=$ENC_REDIRECT2&scope=$ENC_SCOPE&code_challenge_method=S256&code_challenge=$CODE_CHALLENGE&state=$STATE"
          # POST consent
          curl -fsS --retry 3 --retry-all-errors -i -c cookies.txt -b cookies.txt \
            -X POST "$AUTH_URL2" -H 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'confirm=yes' -D auth2.out -o /dev/null || true
          CODE2=$(awk 'BEGIN{IGNORECASE=1} /^Location: /{print $2}' auth2.out | tr -d '\r' | sed -E 's/.*[?&]code=([^&]+).*/\1/')
          if [ -z "$CODE2" ]; then echo "Failed to extract code for confidential (post)"; exit 1; fi
          curl -fsS --retry 3 --retry-all-errors -X POST "$BASE/token" \
            -H 'Content-Type: application/x-www-form-urlencoded' \
            --data-urlencode 'grant_type=authorization_code' \
            --data-urlencode "client_id=$CPOST_ID" \
            --data-urlencode "client_secret=$CPOST_SECRET" \
            --data-urlencode "code_verifier=$CODE_VERIFIER" \
            --data-urlencode "code=$CODE2" \
            --data-urlencode "redirect_uri=$RURI2" | tee token_post.json
          jq -e '.access_token != null' token_post.json >/dev/null || { cat token_post.json; exit 1; }

      - name: Confidential client flow (client_secret_basic)
        run: |
          set -euo pipefail
          SUFFIX=$(uv run python -c "import secrets; print(secrets.token_hex(3))")
          CBASIC_ID="ci-conf-basic-$SUFFIX"
          CBASIC_SECRET=$(uv run python -c "import secrets; print(secrets.token_urlsafe(24))")
          RURI3="http://localhost:5001/oauth2/callback"
          curl -fsS --retry 3 --retry-all-errors -X POST "$BASE/admin/clients" \
            -H "X-Admin-Token: $ADMIN_TOKEN" -H 'Content-Type: application/json' \
            -d "{\"client_id\":\"$CBASIC_ID\",\"client_secret\":\"$CBASIC_SECRET\",\"client_name\":\"CI Confidential BASIC\",\"redirect_uris\":\"http://127.0.0.1:5001/oauth2/callback $RURI3\",\"scope\":\"openid profile email offline_access\",\"grant_types\":\"authorization_code refresh_token\",\"response_types\":\"code\",\"token_endpoint_auth_method\":\"client_secret_basic\"}" -o /dev/null
          ENC_REDIRECT3=$(uv run python -c "import sys, urllib.parse as u; print(u.quote_plus(sys.argv[1]))" "$RURI3")
          AUTH_URL3="$BASE/authorize?client_id=$CBASIC_ID&response_type=code&redirect_uri=$ENC_REDIRECT3&scope=$ENC_SCOPE&code_challenge_method=S256&code_challenge=$CODE_CHALLENGE&state=$STATE"
          curl -fsS --retry 3 --retry-all-errors -i -c cookies.txt -b cookies.txt \
            -X POST "$AUTH_URL3" -H 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'confirm=yes' -D auth3.out -o /dev/null || true
          CODE3=$(awk 'BEGIN{IGNORECASE=1} /^Location: /{print $2}' auth3.out | tr -d '\r' | sed -E 's/.*[?&]code=([^&]+).*/\1/')
          if [ -z "$CODE3" ]; then echo "Failed to extract code for confidential (basic)"; exit 1; fi
          curl -fsS --retry 3 --retry-all-errors -u "$CBASIC_ID:$CBASIC_SECRET" -X POST "$BASE/token" \
            -H 'Content-Type: application/x-www-form-urlencoded' \
            --data-urlencode 'grant_type=authorization_code' \
            --data-urlencode "code_verifier=$CODE_VERIFIER" \
            --data-urlencode "code=$CODE3" \
            --data-urlencode "redirect_uri=$RURI3" | tee token_basic.json
          jq -e '.access_token != null' token_basic.json >/dev/null || { cat token_basic.json; exit 1; }

      - name: Show last server logs (on failure)
        if: failure()
        run: |
          echo '--- server.log (tail) ---'
          tail -n 200 server.log || true

      - name: Upload artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: dev-e2e-${{ matrix.python-version }}
          path: |
            server.log
            token.json
            token2.json
            userinfo.json
            pkce.json
            login.out
            auth.out
            auth2.out
            auth3.out
            token_post.json
            token_basic.json
          if-no-files-found: ignore

      - name: Shutdown server
        if: always()
        run: |
          if [ -f server.pid ]; then kill $(cat server.pid) || true; fi
          sleep 1
          echo '--- server.log (tail after shutdown) ---'
          tail -n 200 server.log || true

  prod-like:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ['3.10', '3.11', '3.12']
    timeout-minutes: 15
    env:
      BASE: http://127.0.0.1:8000
      ADMIN_TOKEN: ci-admin-token
      CLIENT_ID: ci-spa
      REDIRECT_URI: http://localhost:3000/callback
      SCOPE: openid profile email offline_access
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Set up uv
        uses: astral-sh/setup-uv@v3

      - name: Cache uv wheels
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/uv
          key: ${{ runner.os }}-uv-${{ matrix.python-version }}-${{ hashFiles('**/server.py') }}
          restore-keys: |
            ${{ runner.os }}-uv-${{ matrix.python-version }}-

      - name: Cache apt packages (jq)
        uses: awalsh128/cache-apt-pkgs-action@v1
        with:
          packages: jq
          version: 1

      - name: Start server (uv)
        run: |
          set -euo pipefail
          nohup uv run --with flask --with authlib --with sqlalchemy server.py > server.log 2>&1 &
          echo $! > server.pid

      - name: Wait for health
        run: |
          set -euo pipefail
          for i in {1..60}; do
            if curl -fsS --retry 3 --retry-all-errors --connect-timeout 2 --max-time 5 "$BASE/health" >/dev/null; then
              echo "Server is healthy"; exit 0; fi
            sleep 1; done
          echo "Server failed to become healthy"; exit 1

      - name: Initialize server (setup admin token)
        run: |
          set -euo pipefail
          curl -fsS --retry 3 --retry-all-errors -X POST "$BASE/setup" \
            -H 'Content-Type: application/x-www-form-urlencoded' \
            --data-urlencode "admin_token=$ADMIN_TOKEN" -o /dev/null

      - name: Create user via Admin API
        run: |
          set -euo pipefail
          NEW_USER="ciuser"
          NEW_PASS="cipass123!"
          curl -fsS --retry 3 --retry-all-errors -X POST "$BASE/admin/users" \
            -H "X-Admin-Token: $ADMIN_TOKEN" -H 'Content-Type: application/json' \
            -d "{\"username\":\"$NEW_USER\",\"password\":\"$NEW_PASS\",\"email\":\"$NEW_USER@example.com\"}" | tee created_user.json

      - name: Create public client via Admin API and require PKCE
        run: |
          set -euo pipefail
          curl -fsS --retry 3 --retry-all-errors -X POST "$BASE/admin/clients" \
            -H "X-Admin-Token: $ADMIN_TOKEN" -H 'Content-Type: application/json' \
            -d "{\"client_id\":\"$CLIENT_ID\",\"client_name\":\"CI SPA\",\"redirect_uris\":\"http://127.0.0.1:3000/callback $REDIRECT_URI\",\"scope\":\"openid profile email offline_access\",\"grant_types\":\"authorization_code refresh_token\",\"response_types\":\"code\",\"token_endpoint_auth_method\":\"none\"}"
          curl -fsS --retry 3 --retry-all-errors -X POST "$BASE/admin/clients/$CLIENT_ID/policy" \
            -H "X-Admin-Token: $ADMIN_TOKEN" -H 'Content-Type: application/json' \
            -d '{"allowed_scopes":"openid profile email offline_access","default_scopes":"openid profile email","require_pkce":true}' -o /dev/null

      - name: Generate PKCE locally
        run: |
          set -euo pipefail
          CODE_VERIFIER=$(uv run python -c "import os,base64; print(base64.urlsafe_b64encode(os.urandom(40)).decode().rstrip('='))")
          CODE_CHALLENGE=$(uv run python -c "import sys,hashlib,base64; v=sys.argv[1]; print(base64.urlsafe_b64encode(hashlib.sha256(v.encode()).digest()).decode().rstrip('='))" "$CODE_VERIFIER")
          echo "CODE_VERIFIER=$CODE_VERIFIER" >> $GITHUB_ENV
          echo "CODE_CHALLENGE=$CODE_CHALLENGE" >> $GITHUB_ENV

      - name: Build authorize URL
        run: |
          set -euo pipefail
          ENC_REDIRECT=$(uv run python -c "import urllib.parse, os; print(urllib.parse.quote_plus(os.environ['REDIRECT_URI']))")
          ENC_SCOPE=$(uv run python -c "import urllib.parse, os; print(urllib.parse.quote_plus(os.environ['SCOPE']))")
          STATE=$(uv run python -c "import secrets; print(secrets.token_urlsafe(16))")
          AUTH_URL="$BASE/authorize?client_id=$CLIENT_ID&response_type=code&redirect_uri=$ENC_REDIRECT&scope=$ENC_SCOPE&code_challenge_method=S256&code_challenge=$CODE_CHALLENGE&state=$STATE"
          echo "AUTH_URL=$AUTH_URL" >> $GITHUB_ENV
          echo "STATE=$STATE" >> $GITHUB_ENV

      - name: Login as new user and consent
        run: |
          set -euo pipefail
          touch cookies.txt
          curl -fsS --retry 3 --retry-all-errors -c cookies.txt -b cookies.txt "$BASE/login" -o /dev/null
          NEXT_ENC=$(uv run python -c "import urllib.parse, os; print(urllib.parse.quote_plus(os.environ['AUTH_URL']))")
          curl -fsS --retry 3 --retry-all-errors -i -c cookies.txt -b cookies.txt \
            -X POST "$BASE/login?next=$NEXT_ENC" -H 'Content-Type: application/x-www-form-urlencoded' \
            --data-urlencode 'username=ciuser' --data-urlencode 'password=cipass123!' -D login.out -o /dev/null
          curl -fsS --retry 3 --retry-all-errors -i -c cookies.txt -b cookies.txt \
            -X POST "$AUTH_URL" -H 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'confirm=yes' -D auth.out -o /dev/null || true
          CODE=$(awk 'BEGIN{IGNORECASE=1} /^Location: /{print $2}' auth.out | tr -d '\r' | sed -E 's/.*[?&]code=([^&]+).*/\1/')
          if [ -z "$CODE" ]; then echo "Failed to extract code"; exit 1; fi
          echo "CODE=$CODE" >> $GITHUB_ENV

      - name: Exchange code and test APIs (prod-like)
        run: |
          set -euo pipefail
          curl -fsS --retry 3 --retry-all-errors -X POST "$BASE/token" \
            -H 'Content-Type: application/x-www-form-urlencoded' \
            --data-urlencode 'grant_type=authorization_code' \
            --data-urlencode "client_id=$CLIENT_ID" \
            --data-urlencode "code_verifier=$CODE_VERIFIER" \
            --data-urlencode "code=$CODE" \
            --data-urlencode "redirect_uri=$REDIRECT_URI" | tee token.json
          ACCESS_TOKEN=$(jq -r '.access_token' token.json)
          REFRESH_TOKEN=$(jq -r '.refresh_token' token.json)
          if [ -z "$ACCESS_TOKEN" ] || [ -z "$REFRESH_TOKEN" ]; then echo "Missing tokens"; cat token.json; exit 1; fi
          curl -fsS --retry 3 --retry-all-errors "$BASE/userinfo" -H "Authorization: Bearer $ACCESS_TOKEN" | tee userinfo.json
          jq -e '.preferred_username == "ciuser"' userinfo.json >/dev/null || { cat userinfo.json; exit 1; }
          # Introspect current token should be active
          curl -fsS --retry 3 --retry-all-errors -X POST "$BASE/introspect" -d "client_id=$CLIENT_ID" -d "token=$ACCESS_TOKEN" | tee introspect_before.json
          jq -e '.active == true' introspect_before.json >/dev/null || { cat introspect_before.json; exit 1; }
          # Refresh
          curl -fsS --retry 3 --retry-all-errors -X POST "$BASE/token" -H 'Content-Type: application/x-www-form-urlencoded' \
            --data-urlencode 'grant_type=refresh_token' --data-urlencode "client_id=$CLIENT_ID" --data-urlencode "refresh_token=$REFRESH_TOKEN" | tee token2.json
          ACCESS_TOKEN2=$(jq -r '.access_token' token2.json)
          # Old token should now be inactive
          curl -fsS --retry 3 --retry-all-errors -X POST "$BASE/introspect" -d "client_id=$CLIENT_ID" -d "token=$ACCESS_TOKEN" | tee introspect_old_after_refresh.json
          jq -e '.active == false' introspect_old_after_refresh.json >/dev/null || { cat introspect_old_after_refresh.json; exit 1; }
          # New token is active
          curl -fsS --retry 3 --retry-all-errors -X POST "$BASE/introspect" -d "client_id=$CLIENT_ID" -d "token=$ACCESS_TOKEN2" | tee introspect_new.json
          jq -e '.active == true' introspect_new.json >/dev/null || { cat introspect_new.json; exit 1; }
          # Revoke new token and ensure inactive
          curl -fsS --retry 3 --retry-all-errors -X POST "$BASE/revoke" -d "client_id=$CLIENT_ID" -d "token=$ACCESS_TOKEN2" -o /dev/null
          curl -fsS --retry 3 --retry-all-errors -X POST "$BASE/introspect" -d "client_id=$CLIENT_ID" -d "token=$ACCESS_TOKEN2" | tee introspect_new_after_revoke.json
          jq -e '.active == false' introspect_new_after_revoke.json >/dev/null || { cat introspect_new_after_revoke.json; exit 1; }
          # Logout redirect
          STATE=$(uv run python -c "import secrets; print(secrets.token_urlsafe(8))")
          curl -fsS -i "$BASE/logout?client_id=$CLIENT_ID&post_logout_redirect_uri=$REDIRECT_URI&state=$STATE" -D logout.out -o /dev/null
          awk 'BEGIN{IGNORECASE=1} /^Location: /{print $2}' logout.out | tr -d '\r' | grep -q "$REDIRECT_URI" || { echo "Logout redirect not allowed"; exit 1; }

      - name: Upload artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: prod-like-${{ matrix.python-version }}
          path: |
            server.log
            *.json
            login.out
            auth.out
            logout.out
          if-no-files-found: ignore

      - name: Shutdown server
        if: always()
        run: |
          if [ -f server.pid ]; then kill $(cat server.pid) || true; fi
          sleep 1
          echo '--- server.log (tail after shutdown) ---'
          tail -n 200 server.log || true
